module.exports = {

"[externals]/ [external] (next/dist/compiled/next-server/app-route.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/compiled/next-server/app-route.runtime.dev.js");

module.exports = mod;
}}),
"[externals]/ [external] (@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("@opentelemetry/api");

module.exports = mod;
}}),
"[externals]/ [external] (next/dist/compiled/next-server/app-page.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/compiled/next-server/app-page.runtime.dev.js");

module.exports = mod;
}}),
"[externals]/ [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/server/app-render/work-unit-async-storage.external.js");

module.exports = mod;
}}),
"[externals]/ [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/server/app-render/work-async-storage.external.js");

module.exports = mod;
}}),
"[project]/lib/supabase-admin.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "createCompany": (()=>createCompany),
    "createStore": (()=>createStore),
    "createUser": (()=>createUser),
    "default": (()=>__TURBOPACK__default__export__),
    "deleteUser": (()=>deleteUser),
    "getAllCompanies": (()=>getAllCompanies),
    "getAllStores": (()=>getAllStores),
    "getAllUsers": (()=>getAllUsers),
    "getCompanyById": (()=>getCompanyById),
    "getStoreById": (()=>getStoreById),
    "getStoresByCompany": (()=>getStoresByCompany),
    "getUserById": (()=>getUserById),
    "getUsersByCompany": (()=>getUsersByCompany),
    "supabaseAdmin": (()=>supabaseAdmin),
    "updateCompany": (()=>updateCompany),
    "updateStore": (()=>updateStore),
    "updateUser": (()=>updateUser),
    "verifyToken": (()=>verifyToken)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@supabase/supabase-js/dist/index.mjs [app-route] (ecmascript) <locals>");
;
// URL e Service Key do Supabase (server-side only)
const supabaseUrl = process.env.SUPABASE_URL || ("TURBOPACK compile-time value", "https://eetduqcmjucslzedsotg.supabase.co") || 'http://kong:8000';
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SECRET_KEY || process.env.SUPABASE_SERVICE_KEY || '';
if (!supabaseServiceKey) {
    console.warn('??  SUPABASE_SERVICE_ROLE_KEY or SUPABASE_SECRET_KEY not set - admin client will not work');
}
const supabaseAdmin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(supabaseUrl, supabaseServiceKey, {
    auth: {
        autoRefreshToken: false,
        persistSession: false
    }
});
function mapUserRow(row) {
    const lastSeen = row.last_seen ?? null;
    const isOnline = lastSeen ? Date.now() - new Date(lastSeen).getTime() < 5 * 60 * 1000 : false;
    return {
        id: row.id,
        email: row.email,
        displayName: row.display_name || row.email || 'Sem nome',
        role: row.role,
        companyId: row.company_id,
        storeId: row.store_id,
        storeIds: Array.isArray(row.store_ids) ? row.store_ids : row.store_id ? [
            row.store_id
        ] : [],
        active: row.active !== false,
        createdAt: row.created_at,
        lastSeen,
        isOnline
    };
}
function mapCompanyRow(row) {
    return {
        id: row.id,
        name: row.name,
        tradingName: row.trading_name ?? undefined,
        cnpj: row.cnpj ?? undefined,
        active: row.active !== false,
        createdAt: row.created_at,
        updatedAt: row.updated_at
    };
}
function mapStoreRow(row) {
    return {
        id: row.id,
        name: row.name,
        code: row.code,
        companyId: row.company_id,
        managerId: row.manager_id ?? null,
        agentId: row.agent_id ?? null,
        address: row.address ?? undefined,
        city: row.city ?? undefined,
        state: row.state ?? undefined,
        active: row.active !== false,
        createdAt: row.created_at,
        updatedAt: row.updated_at
    };
}
async function getAllUsers() {
    const { data, error } = await supabaseAdmin.from('users').select('*').order('created_at', {
        ascending: false
    });
    if (error) throw error;
    return (data || []).map(mapUserRow);
}
async function getUserById(userId) {
    const { data, error } = await supabaseAdmin.from('users').select('*').eq('id', userId).single();
    if (error) throw error;
    return mapUserRow(data);
}
async function getUsersByCompany(companyId) {
    const { data, error } = await supabaseAdmin.from('users').select('*').eq('company_id', companyId).order('created_at', {
        ascending: false
    });
    if (error) throw error;
    return (data || []).map(mapUserRow);
}
async function createUser(user) {
    const payload = {
        id: user.id,
        email: user.email,
        display_name: user.displayName ?? null,
        role: user.role,
        company_id: user.companyId ?? null,
        store_id: user.storeId ?? null,
        store_ids: user.storeIds ?? (user.storeId ? [
            user.storeId
        ] : []),
        active: user.active ?? true
    };
    const { data, error } = await supabaseAdmin.from('users').insert(payload).select().single();
    if (error) throw error;
    return mapUserRow(data);
}
async function updateUser(userId, updates) {
    const payload = {
        display_name: updates.displayName,
        role: updates.role,
        company_id: updates.companyId ?? undefined,
        store_id: updates.storeId ?? undefined,
        store_ids: updates.storeIds,
        active: typeof updates.active === 'boolean' ? updates.active : undefined,
        updated_at: new Date().toISOString()
    };
    const { data, error } = await supabaseAdmin.from('users').update(payload).eq('id', userId).select().single();
    if (error) throw error;
    return mapUserRow(data);
}
async function deleteUser(userId) {
    const { error } = await supabaseAdmin.from('users').delete().eq('id', userId);
    if (error) throw error;
}
async function getAllCompanies() {
    const { data, error } = await supabaseAdmin.from('companies').select('*').order('name', {
        ascending: true
    });
    if (error) throw error;
    return (data || []).map(mapCompanyRow);
}
async function getCompanyById(companyId) {
    const { data, error } = await supabaseAdmin.from('companies').select('*').eq('id', companyId).single();
    if (error) throw error;
    return mapCompanyRow(data);
}
async function createCompany(company) {
    const payload = {
        id: company.id,
        name: company.name,
        trading_name: company.tradingName ?? null,
        cnpj: company.cnpj ?? null,
        active: company.active ?? true
    };
    const { data, error } = await supabaseAdmin.from('companies').insert(payload).select().single();
    if (error) throw error;
    return mapCompanyRow(data);
}
async function updateCompany(companyId, updates) {
    const payload = {
        name: updates.name,
        trading_name: updates.tradingName ?? undefined,
        cnpj: updates.cnpj ?? undefined,
        active: typeof updates.active === 'boolean' ? updates.active : undefined,
        updated_at: new Date().toISOString()
    };
    const { data, error } = await supabaseAdmin.from('companies').update(payload).eq('id', companyId).select().single();
    if (error) throw error;
    return mapCompanyRow(data);
}
async function getAllStores() {
    const { data, error } = await supabaseAdmin.from('stores').select('*').order('name', {
        ascending: true
    });
    if (error) throw error;
    return (data || []).map(mapStoreRow);
}
async function getStoresByCompany(companyId) {
    const { data, error } = await supabaseAdmin.from('stores').select('*').eq('company_id', companyId).order('name', {
        ascending: true
    });
    if (error) throw error;
    return (data || []).map(mapStoreRow);
}
async function getStoreById(storeId) {
    const { data, error } = await supabaseAdmin.from('stores').select('*').eq('id', storeId).single();
    if (error) throw error;
    return mapStoreRow(data);
}
async function createStore(store) {
    const payload = {
        id: store.id,
        name: store.name,
        code: store.code,
        company_id: store.companyId,
        manager_id: store.managerId ?? null,
        agent_id: store.agentId ?? null,
        address: store.address ?? null,
        city: store.city ?? null,
        state: store.state ?? null,
        active: store.active ?? true
    };
    const { data, error } = await supabaseAdmin.from('stores').insert(payload).select().single();
    if (error) throw error;
    return mapStoreRow(data);
}
async function updateStore(storeId, updates) {
    const payload = {
        name: updates.name,
        code: updates.code,
        company_id: updates.companyId,
        manager_id: updates.managerId ?? undefined,
        agent_id: updates.agentId ?? undefined,
        address: updates.address ?? undefined,
        city: updates.city ?? undefined,
        state: updates.state ?? undefined,
        active: typeof updates.active === 'boolean' ? updates.active : undefined,
        updated_at: new Date().toISOString()
    };
    const { data, error } = await supabaseAdmin.from('stores').update(payload).eq('id', storeId).select().single();
    if (error) throw error;
    return mapStoreRow(data);
}
async function verifyToken(token) {
    const { data: { user }, error } = await supabaseAdmin.auth.getUser(token);
    if (error) throw error;
    return user;
}
const __TURBOPACK__default__export__ = supabaseAdmin;
}}),
"[project]/app/api/mensagens/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "GET": (()=>GET),
    "POST": (()=>POST),
    "dynamic": (()=>dynamic),
    "revalidate": (()=>revalidate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/lib/supabase-admin.ts [app-route] (ecmascript)");
;
;
const dynamic = 'force-dynamic';
const revalidate = 0;
async function GET(req) {
    const { searchParams } = new URL(req.url);
    const userId = searchParams.get('userId');
    try {
        let query = __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('conversations').select('*');
        // Se userId fornecido, filtrar conversas do usuário (participants é array)
        if (userId) {
            query = query.contains('participants', [
                userId
            ]);
        }
        const { data: conversationsData, error: conversationsError } = await query;
        // Se a tabela não existir ou houver erro, retorna lista vazia
        if (conversationsError) {
            console.error('[Mensagens] Erro ao listar conversas:', conversationsError);
            // Se for erro de tabela não existente, retorna lista vazia
            if (conversationsError.code === '42P01' || conversationsError.message?.includes('does not exist')) {
                console.warn('[Mensagens] Tabela conversations não existe ainda');
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    conversations: [],
                    onlineStatus: {}
                });
            }
            // Para outros erros, também retorna lista vazia para não quebrar a UI
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                conversations: [],
                onlineStatus: {}
            });
        }
        // Buscar status online dos participantes
        const allParticipantIds = new Set();
        (conversationsData || []).forEach((conv)=>{
            const participants = conv?.participants || [];
            participants.forEach((id)=>allParticipantIds.add(id));
        });
        // Buscar informações de presença dos usuários
        const onlineStatus = {};
        if (allParticipantIds.size > 0) {
            const { data: users, error: usersError } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('users').select('id, last_seen').in('id', Array.from(allParticipantIds));
            if (!usersError && users) {
                users.forEach((user)=>{
                    const lastSeen = user.last_seen ? new Date(user.last_seen) : null;
                    // Considera online se lastSeen foi nos últimos 5 minutos
                    onlineStatus[user.id] = lastSeen ? Date.now() - lastSeen.getTime() < 5 * 60 * 1000 : false;
                });
            }
        }
        // Mapear conversas
        let conversations = (conversationsData || []).map((data)=>({
                id: data.id,
                participants: data.participants || [],
                participantNames: data.participant_names || {},
                lastMessage: data.last_message || '',
                lastMessageAt: data.last_message_at || new Date(0).toISOString(),
                lastMessageBy: data.last_message_by || '',
                unreadCount: data.unread_count || {},
                createdAt: data.created_at || new Date(0).toISOString(),
                onlineStatus
            }));
        // Ordenar por lastMessageAt
        conversations.sort((a, b)=>{
            const dateA = new Date(a.lastMessageAt).getTime();
            const dateB = new Date(b.lastMessageAt).getTime();
            return dateB - dateA;
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            conversations
        });
    } catch (error) {
        console.error('Erro ao listar conversas:', error);
        // Retorna lista vazia em vez de erro para não quebrar a UI
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            conversations: [],
            onlineStatus: {}
        });
    }
}
async function POST(request) {
    try {
        const body = await request.json().catch(()=>({}));
        const senderId = body.senderId || body.from;
        const receiverId = body.receiverId || body.to;
        const text = body.text || body.body || body.mensagem || '';
        const senderName = body.senderName;
        if (!senderId || !receiverId || !text && !(Array.isArray(body.attachments) && body.attachments.length > 0)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'senderId, receiverId e text são obrigatórios'
            }, {
                status: 400
            });
        }
        // Buscar ou criar conversa entre os dois usuários
        const participants = [
            senderId,
            receiverId
        ].sort();
        const { data: existingConversations, error: searchError } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('conversations').select('*').contains('participants', participants).limit(1);
        if (searchError) throw searchError;
        let conversationId;
        if (existingConversations && existingConversations.length > 0) {
            // Conversa já existe
            conversationId = existingConversations[0].id;
        } else {
            // Criar nova conversa - buscar nomes dos usuários
            const { data: users, error: usersError } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('users').select('id, display_name').in('id', participants);
            if (usersError) throw usersError;
            const participantNames = {};
            users?.forEach((user)=>{
                participantNames[user.id] = user.display_name || 'Usuário';
            });
            const messagePreview = text && text.trim().length > 0 ? text : Array.isArray(body.attachments) && body.attachments.length > 0 ? body.attachments[0]?.type === 'image' ? '[imagem]' : '[arquivo]' : '';
            const unreadCount = {};
            unreadCount[senderId] = 0;
            unreadCount[receiverId] = 1;
            const { data: newConversation, error: createError } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('conversations').insert({
                participants,
                participant_names: participantNames,
                last_message: messagePreview,
                last_message_at: new Date().toISOString(),
                last_message_by: senderId,
                unread_count: unreadCount,
                created_at: new Date().toISOString()
            }).select().single();
            if (createError) throw createError;
            conversationId = newConversation.id;
        }
        // Preparar dados da mensagem
        const messageData = {
            conversation_id: conversationId,
            sender_id: senderId,
            sender_name: senderName || 'Usuário',
            receiver_id: receiverId,
            text,
            created_at: new Date().toISOString(),
            read: false
        };
        // Adicionar attachments se fornecidos
        if (body.attachments && Array.isArray(body.attachments)) {
            messageData.attachments = body.attachments;
        }
        // Adicionar mensagem
        const { error: messageError } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('chat_messages').insert(messageData);
        if (messageError) throw messageError;
        // Atualizar conversa com última mensagem
        const messagePreview = text && text.trim().length > 0 ? text : Array.isArray(body.attachments) && body.attachments.length > 0 ? body.attachments[0]?.type === 'image' ? '[imagem]' : '[arquivo]' : '';
        // Buscar unread_count atual
        const { data: currentConv } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('conversations').select('unread_count').eq('id', conversationId).single();
        const currentUnreadCount = currentConv?.unread_count || {};
        const newUnreadCount = {
            ...currentUnreadCount
        };
        newUnreadCount[receiverId] = (newUnreadCount[receiverId] || 0) + 1;
        await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('conversations').update({
            last_message: messagePreview,
            last_message_at: new Date().toISOString(),
            last_message_by: senderId,
            unread_count: newUnreadCount
        }).eq('id', conversationId);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            conversationId,
            message: 'Mensagem enviada com sucesso'
        }, {
            status: 201
        });
    } catch (error) {
        console.error('Erro ao criar mensagem:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Falha ao criar mensagem'
        }, {
            status: 500
        });
    }
}
}}),
"[project]/ (server-utils)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: require } = __turbopack_context__;
{
}}),

};

//# sourceMappingURL=%5Broot%20of%20the%20server%5D__12fb6b._.js.map