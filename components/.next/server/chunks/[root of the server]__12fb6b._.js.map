{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/lib/supabase-admin.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\n\n// URL e Service Key do Supabase (server-side only)\nconst supabaseUrl = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL || 'http://kong:8000';\nconst supabaseServiceKey =\n  process.env.SUPABASE_SERVICE_ROLE_KEY ||\n  process.env.SUPABASE_SECRET_KEY ||\n  process.env.SUPABASE_SERVICE_KEY ||\n  '';\n\nif (!supabaseServiceKey) {\n  console.warn('??  SUPABASE_SERVICE_ROLE_KEY or SUPABASE_SECRET_KEY not set - admin client will not work');\n}\n\n// Cliente Supabase Admin (bypassa Row Level Security)\n// APENAS para uso server-side (API routes, server components)\nexport const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false,\n  },\n});\n\n/**\n * Tipos de dados do banco\n */\n\nexport interface User {\n  id: string;\n  email: string;\n  displayName: string;\n  role: 'developer' | 'admin' | 'manager' | 'agent' | 'buyer';\n  companyId: string | null;\n  storeId: string | null;\n  storeIds: string[];\n  active: boolean;\n  createdAt: string;\n  lastSeen: string | null;\n  isOnline?: boolean;\n}\n\nexport interface Company {\n  id: string;\n  name: string;\n  tradingName?: string;\n  cnpj?: string;\n  active: boolean;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface Store {\n  id: string;\n  name: string;\n  code: string;\n  companyId: string;\n  managerId?: string | null;\n  agentId?: string | null;\n  address?: string;\n  city?: string;\n  state?: string;\n  active: boolean;\n  createdAt: string;\n  updatedAt: string;\n}\n\ntype DbUser = {\n  id: string;\n  email: string;\n  display_name: string | null;\n  role: string;\n  company_id: string | null;\n  store_id: string | null;\n  store_ids: string[] | null;\n  active: boolean | null;\n  created_at: string;\n  last_seen: string | null;\n};\n\ntype DbCompany = {\n  id: string;\n  name: string;\n  cnpj: string | null;\n  trading_name: string | null;\n  active: boolean | null;\n  created_at: string;\n  updated_at: string;\n};\n\ntype DbStore = {\n  id: string;\n  name: string;\n  code: string;\n  company_id: string;\n  manager_id: string | null;\n  agent_id: string | null;\n  address: string | null;\n  city: string | null;\n  state: string | null;\n  active: boolean | null;\n  created_at: string;\n  updated_at: string;\n};\n\nfunction mapUserRow(row: DbUser): User {\n  const lastSeen = row.last_seen ?? null;\n  const isOnline = lastSeen ? (Date.now() - new Date(lastSeen).getTime() < 5 * 60 * 1000) : false;\n  return {\n    id: row.id,\n    email: row.email,\n    displayName: row.display_name || row.email || 'Sem nome',\n    role: row.role as User['role'],\n    companyId: row.company_id,\n    storeId: row.store_id,\n    storeIds: Array.isArray(row.store_ids) ? row.store_ids : (row.store_id ? [row.store_id] : []),\n    active: row.active !== false,\n    createdAt: row.created_at,\n    lastSeen,\n    isOnline,\n  };\n}\n\nfunction mapCompanyRow(row: DbCompany): Company {\n  return {\n    id: row.id,\n    name: row.name,\n    tradingName: row.trading_name ?? undefined,\n    cnpj: row.cnpj ?? undefined,\n    active: row.active !== false,\n    createdAt: row.created_at,\n    updatedAt: row.updated_at,\n  };\n}\n\nfunction mapStoreRow(row: DbStore): Store {\n  return {\n    id: row.id,\n    name: row.name,\n    code: row.code,\n    companyId: row.company_id,\n    managerId: row.manager_id ?? null,\n    agentId: row.agent_id ?? null,\n    address: row.address ?? undefined,\n    city: row.city ?? undefined,\n    state: row.state ?? undefined,\n    active: row.active !== false,\n    createdAt: row.created_at,\n    updatedAt: row.updated_at,\n  };\n}\n\n/**\n * Helper Functions para opera‡äes comuns\n */\n\n// ========================================\n// USERS\n// ========================================\n\nexport async function getAllUsers() {\n  const { data, error } = await supabaseAdmin\n    .from('users')\n    .select('*')\n    .order('created_at', { ascending: false });\n\n  if (error) throw error;\n  return (data || []).map(mapUserRow);\n}\n\nexport async function getUserById(userId: string) {\n  const { data, error } = await supabaseAdmin\n    .from('users')\n    .select('*')\n    .eq('id', userId)\n    .single();\n\n  if (error) throw error;\n  return mapUserRow(data as DbUser);\n}\n\nexport async function getUsersByCompany(companyId: string) {\n  const { data, error } = await supabaseAdmin\n    .from('users')\n    .select('*')\n    .eq('company_id', companyId)\n    .order('created_at', { ascending: false });\n\n  if (error) throw error;\n  return (data || []).map(mapUserRow);\n}\n\nexport async function createUser(user: Partial<User>) {\n  const payload = {\n    id: user.id,\n    email: user.email,\n    display_name: user.displayName ?? null,\n    role: user.role,\n    company_id: user.companyId ?? null,\n    store_id: user.storeId ?? null,\n    store_ids: user.storeIds ?? (user.storeId ? [user.storeId] : []),\n    active: user.active ?? true,\n  };\n  const { data, error } = await supabaseAdmin\n    .from('users')\n    .insert(payload)\n    .select()\n    .single();\n\n  if (error) throw error;\n  return mapUserRow(data as DbUser);\n}\n\nexport async function updateUser(userId: string, updates: Partial<User>) {\n  const payload: Partial<DbUser> & { updated_at?: string } = {\n    display_name: updates.displayName,\n    role: updates.role,\n    company_id: updates.companyId ?? undefined,\n    store_id: updates.storeId ?? undefined,\n    store_ids: updates.storeIds,\n    active: typeof updates.active === 'boolean' ? updates.active : undefined,\n    updated_at: new Date().toISOString(),\n  };\n  const { data, error } = await supabaseAdmin\n    .from('users')\n    .update(payload)\n    .eq('id', userId)\n    .select()\n    .single();\n\n  if (error) throw error;\n  return mapUserRow(data as DbUser);\n}\n\nexport async function deleteUser(userId: string) {\n  const { error } = await supabaseAdmin\n    .from('users')\n    .delete()\n    .eq('id', userId);\n\n  if (error) throw error;\n}\n\n// ========================================\n// COMPANIES\n// ========================================\n\nexport async function getAllCompanies() {\n  const { data, error } = await supabaseAdmin\n    .from('companies')\n    .select('*')\n    .order('name', { ascending: true });\n\n  if (error) throw error;\n  return (data || []).map(mapCompanyRow);\n}\n\nexport async function getCompanyById(companyId: string) {\n  const { data, error } = await supabaseAdmin\n    .from('companies')\n    .select('*')\n    .eq('id', companyId)\n    .single();\n\n  if (error) throw error;\n  return mapCompanyRow(data as DbCompany);\n}\n\nexport async function createCompany(company: Partial<Company>) {\n  const payload = {\n    id: company.id,\n    name: company.name,\n    trading_name: company.tradingName ?? null,\n    cnpj: company.cnpj ?? null,\n    active: company.active ?? true,\n  };\n  const { data, error } = await supabaseAdmin\n    .from('companies')\n    .insert(payload)\n    .select()\n    .single();\n\n  if (error) throw error;\n  return mapCompanyRow(data as DbCompany);\n}\n\nexport async function updateCompany(companyId: string, updates: Partial<Company>) {\n  const payload = {\n    name: updates.name,\n    trading_name: updates.tradingName ?? undefined,\n    cnpj: updates.cnpj ?? undefined,\n    active: typeof updates.active === 'boolean' ? updates.active : undefined,\n    updated_at: new Date().toISOString(),\n  };\n  const { data, error } = await supabaseAdmin\n    .from('companies')\n    .update(payload)\n    .eq('id', companyId)\n    .select()\n    .single();\n\n  if (error) throw error;\n  return mapCompanyRow(data as DbCompany);\n}\n\n// ========================================\n// STORES\n// ========================================\n\nexport async function getAllStores() {\n  const { data, error } = await supabaseAdmin\n    .from('stores')\n    .select('*')\n    .order('name', { ascending: true });\n\n  if (error) throw error;\n  return (data || []).map(mapStoreRow);\n}\n\nexport async function getStoresByCompany(companyId: string) {\n  const { data, error } = await supabaseAdmin\n    .from('stores')\n    .select('*')\n    .eq('company_id', companyId)\n    .order('name', { ascending: true });\n\n  if (error) throw error;\n  return (data || []).map(mapStoreRow);\n}\n\nexport async function getStoreById(storeId: string) {\n  const { data, error } = await supabaseAdmin\n    .from('stores')\n    .select('*')\n    .eq('id', storeId)\n    .single();\n\n  if (error) throw error;\n  return mapStoreRow(data as DbStore);\n}\n\nexport async function createStore(store: Partial<Store>) {\n  const payload = {\n    id: store.id,\n    name: store.name,\n    code: store.code,\n    company_id: store.companyId,\n    manager_id: store.managerId ?? null,\n    agent_id: store.agentId ?? null,\n    address: store.address ?? null,\n    city: store.city ?? null,\n    state: store.state ?? null,\n    active: store.active ?? true,\n  };\n  const { data, error } = await supabaseAdmin\n    .from('stores')\n    .insert(payload)\n    .select()\n    .single();\n\n  if (error) throw error;\n  return mapStoreRow(data as DbStore);\n}\n\nexport async function updateStore(storeId: string, updates: Partial<Store>) {\n  const payload = {\n    name: updates.name,\n    code: updates.code,\n    company_id: updates.companyId,\n    manager_id: updates.managerId ?? undefined,\n    agent_id: updates.agentId ?? undefined,\n    address: updates.address ?? undefined,\n    city: updates.city ?? undefined,\n    state: updates.state ?? undefined,\n    active: typeof updates.active === 'boolean' ? updates.active : undefined,\n    updated_at: new Date().toISOString(),\n  };\n  const { data, error } = await supabaseAdmin\n    .from('stores')\n    .update(payload)\n    .eq('id', storeId)\n    .select()\n    .single();\n\n  if (error) throw error;\n  return mapStoreRow(data as DbStore);\n}\n\n/**\n * Helper para verificar JWT token do usu rio\n */\nexport async function verifyToken(token: string) {\n  const { data: { user }, error } = await supabaseAdmin.auth.getUser(token);\n\n  if (error) throw error;\n  return user;\n}\n\nexport default supabaseAdmin;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 282, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/app/api/mensagens/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { supabaseAdmin } from '@/lib/supabase-admin';\n\n// Desabilitar cache para sempre retornar dados atualizados\nexport const dynamic = 'force-dynamic';\nexport const revalidate = 0;\n\n/**\n * GET /api/mensagens\n * Lista todas as conversas (conversations) do sistema\n * Compatível com estrutura do mobile: conversations collection\n *\n * Query params:\n * - userId: filtrar apenas conversas de um usuário específico\n */\nexport async function GET(req: NextRequest) {\n  const { searchParams } = new URL(req.url);\n  const userId = searchParams.get('userId');\n\n  try {\n    let query = supabaseAdmin.from('conversations').select('*');\n\n    // Se userId fornecido, filtrar conversas do usuário (participants é array)\n    if (userId) {\n      query = query.contains('participants', [userId]);\n    }\n\n    const { data: conversationsData, error: conversationsError } = await query;\n\n    // Se a tabela não existir ou houver erro, retorna lista vazia\n    if (conversationsError) {\n      console.error('[Mensagens] Erro ao listar conversas:', conversationsError);\n\n      // Se for erro de tabela não existente, retorna lista vazia\n      if (conversationsError.code === '42P01' || conversationsError.message?.includes('does not exist')) {\n        console.warn('[Mensagens] Tabela conversations não existe ainda');\n        return NextResponse.json({ conversations: [], onlineStatus: {} });\n      }\n\n      // Para outros erros, também retorna lista vazia para não quebrar a UI\n      return NextResponse.json({ conversations: [], onlineStatus: {} });\n    }\n\n    // Buscar status online dos participantes\n    const allParticipantIds = new Set<string>();\n    (conversationsData || []).forEach((conv: any) => {\n      const participants = conv?.participants || [];\n      participants.forEach((id: string) => allParticipantIds.add(id));\n    });\n\n    // Buscar informações de presença dos usuários\n    const onlineStatus: Record<string, boolean> = {};\n    if (allParticipantIds.size > 0) {\n      const { data: users, error: usersError } = await supabaseAdmin\n        .from('users')\n        .select('id, last_seen')\n        .in('id', Array.from(allParticipantIds));\n\n      if (!usersError && users) {\n        users.forEach((user: any) => {\n          const lastSeen = user.last_seen ? new Date(user.last_seen) : null;\n          // Considera online se lastSeen foi nos últimos 5 minutos\n          onlineStatus[user.id] = lastSeen ? (Date.now() - lastSeen.getTime() < 5 * 60 * 1000) : false;\n        });\n      }\n    }\n\n    // Mapear conversas\n    let conversations = (conversationsData || []).map((data: any) => ({\n      id: data.id,\n      participants: data.participants || [],\n      participantNames: data.participant_names || {},\n      lastMessage: data.last_message || '',\n      lastMessageAt: data.last_message_at || new Date(0).toISOString(),\n      lastMessageBy: data.last_message_by || '',\n      unreadCount: data.unread_count || {},\n      createdAt: data.created_at || new Date(0).toISOString(),\n      onlineStatus, // Status online de todos os participantes\n    }));\n\n    // Ordenar por lastMessageAt\n    conversations.sort((a: any, b: any) => {\n      const dateA = new Date(a.lastMessageAt).getTime();\n      const dateB = new Date(b.lastMessageAt).getTime();\n      return dateB - dateA;\n    });\n\n    return NextResponse.json({ conversations });\n  } catch (error: any) {\n    console.error('Erro ao listar conversas:', error);\n    // Retorna lista vazia em vez de erro para não quebrar a UI\n    return NextResponse.json({ conversations: [], onlineStatus: {} });\n  }\n}\n\n/**\n * POST /api/mensagens\n * Cria uma nova conversa ou envia mensagem em conversa existente\n * Compatível com estrutura do mobile: conversations/{id}/messages\n */\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json().catch(() => ({}));\n    const senderId = body.senderId || body.from;\n    const receiverId = body.receiverId || body.to;\n    const text = body.text || body.body || body.mensagem || '';\n    const senderName = body.senderName;\n\n    if (!senderId || !receiverId || (!text && !(Array.isArray(body.attachments) && body.attachments.length > 0))) {\n      return NextResponse.json(\n        { error: 'senderId, receiverId e text são obrigatórios' },\n        { status: 400 }\n      );\n    }\n\n    // Buscar ou criar conversa entre os dois usuários\n    const participants = [senderId, receiverId].sort();\n\n    const { data: existingConversations, error: searchError } = await supabaseAdmin\n      .from('conversations')\n      .select('*')\n      .contains('participants', participants)\n      .limit(1);\n\n    if (searchError) throw searchError;\n\n    let conversationId: string;\n\n    if (existingConversations && existingConversations.length > 0) {\n      // Conversa já existe\n      conversationId = existingConversations[0].id;\n    } else {\n      // Criar nova conversa - buscar nomes dos usuários\n      const { data: users, error: usersError } = await supabaseAdmin\n        .from('users')\n        .select('id, display_name')\n        .in('id', participants);\n\n      if (usersError) throw usersError;\n\n      const participantNames: Record<string, string> = {};\n      users?.forEach((user: any) => {\n        participantNames[user.id] = user.display_name || 'Usuário';\n      });\n\n      const messagePreview = (text && text.trim().length > 0)\n        ? text\n        : (Array.isArray(body.attachments) && body.attachments.length > 0\n          ? (body.attachments[0]?.type === 'image' ? '[imagem]' : '[arquivo]')\n          : '');\n\n      const unreadCount: Record<string, number> = {};\n      unreadCount[senderId] = 0;\n      unreadCount[receiverId] = 1;\n\n      const { data: newConversation, error: createError } = await supabaseAdmin\n        .from('conversations')\n        .insert({\n          participants,\n          participant_names: participantNames,\n          last_message: messagePreview,\n          last_message_at: new Date().toISOString(),\n          last_message_by: senderId,\n          unread_count: unreadCount,\n          created_at: new Date().toISOString(),\n        })\n        .select()\n        .single();\n\n      if (createError) throw createError;\n\n      conversationId = newConversation.id;\n    }\n\n    // Preparar dados da mensagem\n    const messageData: any = {\n      conversation_id: conversationId,\n      sender_id: senderId,\n      sender_name: senderName || 'Usuário',\n      receiver_id: receiverId,\n      text,\n      created_at: new Date().toISOString(),\n      read: false,\n    };\n\n    // Adicionar attachments se fornecidos\n    if (body.attachments && Array.isArray(body.attachments)) {\n      messageData.attachments = body.attachments;\n    }\n\n    // Adicionar mensagem\n    const { error: messageError } = await supabaseAdmin\n      .from('chat_messages')\n      .insert(messageData);\n\n    if (messageError) throw messageError;\n\n    // Atualizar conversa com última mensagem\n    const messagePreview = (text && text.trim().length > 0)\n      ? text\n      : (Array.isArray(body.attachments) && body.attachments.length > 0\n        ? (body.attachments[0]?.type === 'image' ? '[imagem]' : '[arquivo]')\n        : '');\n\n    // Buscar unread_count atual\n    const { data: currentConv } = await supabaseAdmin\n      .from('conversations')\n      .select('unread_count')\n      .eq('id', conversationId)\n      .single();\n\n    const currentUnreadCount = currentConv?.unread_count || {};\n    const newUnreadCount = { ...currentUnreadCount };\n    newUnreadCount[receiverId] = (newUnreadCount[receiverId] || 0) + 1;\n\n    await supabaseAdmin\n      .from('conversations')\n      .update({\n        last_message: messagePreview,\n        last_message_at: new Date().toISOString(),\n        last_message_by: senderId,\n        unread_count: newUnreadCount,\n      })\n      .eq('id', conversationId);\n\n    return NextResponse.json(\n      {\n        success: true,\n        conversationId,\n        message: 'Mensagem enviada com sucesso',\n      },\n      { status: 201 }\n    );\n  } catch (error) {\n    console.error('Erro ao criar mensagem:', error);\n    return NextResponse.json({ error: 'Falha ao criar mensagem' }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAGO,MAAM,UAAU;AAChB,MAAM,aAAa;AAUnB,eAAe,IAAI,GAAgB;IACxC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG;IACxC,MAAM,SAAS,aAAa,GAAG,CAAC;IAEhC,IAAI;QACF,IAAI,QAAQ,0HAAA,CAAA,gBAAa,CAAC,IAAI,CAAC,iBAAiB,MAAM,CAAC;QAEvD,2EAA2E;QAC3E,IAAI,QAAQ;YACV,QAAQ,MAAM,QAAQ,CAAC,gBAAgB;gBAAC;aAAO;QACjD;QAEA,MAAM,EAAE,MAAM,iBAAiB,EAAE,OAAO,kBAAkB,EAAE,GAAG,MAAM;QAErE,8DAA8D;QAC9D,IAAI,oBAAoB;YACtB,QAAQ,KAAK,CAAC,yCAAyC;YAEvD,2DAA2D;YAC3D,IAAI,mBAAmB,IAAI,KAAK,WAAW,mBAAmB,OAAO,EAAE,SAAS,mBAAmB;gBACjG,QAAQ,IAAI,CAAC;gBACb,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;oBAAE,eAAe,EAAE;oBAAE,cAAc,CAAC;gBAAE;YACjE;YAEA,sEAAsE;YACtE,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,eAAe,EAAE;gBAAE,cAAc,CAAC;YAAE;QACjE;QAEA,yCAAyC;QACzC,MAAM,oBAAoB,IAAI;QAC9B,CAAC,qBAAqB,EAAE,EAAE,OAAO,CAAC,CAAC;YACjC,MAAM,eAAe,MAAM,gBAAgB,EAAE;YAC7C,aAAa,OAAO,CAAC,CAAC,KAAe,kBAAkB,GAAG,CAAC;QAC7D;QAEA,8CAA8C;QAC9C,MAAM,eAAwC,CAAC;QAC/C,IAAI,kBAAkB,IAAI,GAAG,GAAG;YAC9B,MAAM,EAAE,MAAM,KAAK,EAAE,OAAO,UAAU,EAAE,GAAG,MAAM,0HAAA,CAAA,gBAAa,CAC3D,IAAI,CAAC,SACL,MAAM,CAAC,iBACP,EAAE,CAAC,MAAM,MAAM,IAAI,CAAC;YAEvB,IAAI,CAAC,cAAc,OAAO;gBACxB,MAAM,OAAO,CAAC,CAAC;oBACb,MAAM,WAAW,KAAK,SAAS,GAAG,IAAI,KAAK,KAAK,SAAS,IAAI;oBAC7D,yDAAyD;oBACzD,YAAY,CAAC,KAAK,EAAE,CAAC,GAAG,WAAY,KAAK,GAAG,KAAK,SAAS,OAAO,KAAK,IAAI,KAAK,OAAQ;gBACzF;YACF;QACF;QAEA,mBAAmB;QACnB,IAAI,gBAAgB,CAAC,qBAAqB,EAAE,EAAE,GAAG,CAAC,CAAC,OAAc,CAAC;gBAChE,IAAI,KAAK,EAAE;gBACX,cAAc,KAAK,YAAY,IAAI,EAAE;gBACrC,kBAAkB,KAAK,iBAAiB,IAAI,CAAC;gBAC7C,aAAa,KAAK,YAAY,IAAI;gBAClC,eAAe,KAAK,eAAe,IAAI,IAAI,KAAK,GAAG,WAAW;gBAC9D,eAAe,KAAK,eAAe,IAAI;gBACvC,aAAa,KAAK,YAAY,IAAI,CAAC;gBACnC,WAAW,KAAK,UAAU,IAAI,IAAI,KAAK,GAAG,WAAW;gBACrD;YACF,CAAC;QAED,4BAA4B;QAC5B,cAAc,IAAI,CAAC,CAAC,GAAQ;YAC1B,MAAM,QAAQ,IAAI,KAAK,EAAE,aAAa,EAAE,OAAO;YAC/C,MAAM,QAAQ,IAAI,KAAK,EAAE,aAAa,EAAE,OAAO;YAC/C,OAAO,QAAQ;QACjB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE;QAAc;IAC3C,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,2DAA2D;QAC3D,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,eAAe,EAAE;YAAE,cAAc,CAAC;QAAE;IACjE;AACF;AAOO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QACjD,MAAM,WAAW,KAAK,QAAQ,IAAI,KAAK,IAAI;QAC3C,MAAM,aAAa,KAAK,UAAU,IAAI,KAAK,EAAE;QAC7C,MAAM,OAAO,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI,KAAK,QAAQ,IAAI;QACxD,MAAM,aAAa,KAAK,UAAU;QAElC,IAAI,CAAC,YAAY,CAAC,cAAe,CAAC,QAAQ,CAAC,CAAC,MAAM,OAAO,CAAC,KAAK,WAAW,KAAK,KAAK,WAAW,CAAC,MAAM,GAAG,CAAC,GAAI;YAC5G,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA+C,GACxD;gBAAE,QAAQ;YAAI;QAElB;QAEA,kDAAkD;QAClD,MAAM,eAAe;YAAC;YAAU;SAAW,CAAC,IAAI;QAEhD,MAAM,EAAE,MAAM,qBAAqB,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,0HAAA,CAAA,gBAAa,CAC5E,IAAI,CAAC,iBACL,MAAM,CAAC,KACP,QAAQ,CAAC,gBAAgB,cACzB,KAAK,CAAC;QAET,IAAI,aAAa,MAAM;QAEvB,IAAI;QAEJ,IAAI,yBAAyB,sBAAsB,MAAM,GAAG,GAAG;YAC7D,qBAAqB;YACrB,iBAAiB,qBAAqB,CAAC,EAAE,CAAC,EAAE;QAC9C,OAAO;YACL,kDAAkD;YAClD,MAAM,EAAE,MAAM,KAAK,EAAE,OAAO,UAAU,EAAE,GAAG,MAAM,0HAAA,CAAA,gBAAa,CAC3D,IAAI,CAAC,SACL,MAAM,CAAC,oBACP,EAAE,CAAC,MAAM;YAEZ,IAAI,YAAY,MAAM;YAEtB,MAAM,mBAA2C,CAAC;YAClD,OAAO,QAAQ,CAAC;gBACd,gBAAgB,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,YAAY,IAAI;YACnD;YAEA,MAAM,iBAAiB,AAAC,QAAQ,KAAK,IAAI,GAAG,MAAM,GAAG,IACjD,OACC,MAAM,OAAO,CAAC,KAAK,WAAW,KAAK,KAAK,WAAW,CAAC,MAAM,GAAG,IAC3D,KAAK,WAAW,CAAC,EAAE,EAAE,SAAS,UAAU,aAAa,cACtD;YAEN,MAAM,cAAsC,CAAC;YAC7C,WAAW,CAAC,SAAS,GAAG;YACxB,WAAW,CAAC,WAAW,GAAG;YAE1B,MAAM,EAAE,MAAM,eAAe,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,0HAAA,CAAA,gBAAa,CACtE,IAAI,CAAC,iBACL,MAAM,CAAC;gBACN;gBACA,mBAAmB;gBACnB,cAAc;gBACd,iBAAiB,IAAI,OAAO,WAAW;gBACvC,iBAAiB;gBACjB,cAAc;gBACd,YAAY,IAAI,OAAO,WAAW;YACpC,GACC,MAAM,GACN,MAAM;YAET,IAAI,aAAa,MAAM;YAEvB,iBAAiB,gBAAgB,EAAE;QACrC;QAEA,6BAA6B;QAC7B,MAAM,cAAmB;YACvB,iBAAiB;YACjB,WAAW;YACX,aAAa,cAAc;YAC3B,aAAa;YACb;YACA,YAAY,IAAI,OAAO,WAAW;YAClC,MAAM;QACR;QAEA,sCAAsC;QACtC,IAAI,KAAK,WAAW,IAAI,MAAM,OAAO,CAAC,KAAK,WAAW,GAAG;YACvD,YAAY,WAAW,GAAG,KAAK,WAAW;QAC5C;QAEA,qBAAqB;QACrB,MAAM,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM,0HAAA,CAAA,gBAAa,CAChD,IAAI,CAAC,iBACL,MAAM,CAAC;QAEV,IAAI,cAAc,MAAM;QAExB,yCAAyC;QACzC,MAAM,iBAAiB,AAAC,QAAQ,KAAK,IAAI,GAAG,MAAM,GAAG,IACjD,OACC,MAAM,OAAO,CAAC,KAAK,WAAW,KAAK,KAAK,WAAW,CAAC,MAAM,GAAG,IAC3D,KAAK,WAAW,CAAC,EAAE,EAAE,SAAS,UAAU,aAAa,cACtD;QAEN,4BAA4B;QAC5B,MAAM,EAAE,MAAM,WAAW,EAAE,GAAG,MAAM,0HAAA,CAAA,gBAAa,CAC9C,IAAI,CAAC,iBACL,MAAM,CAAC,gBACP,EAAE,CAAC,MAAM,gBACT,MAAM;QAET,MAAM,qBAAqB,aAAa,gBAAgB,CAAC;QACzD,MAAM,iBAAiB;YAAE,GAAG,kBAAkB;QAAC;QAC/C,cAAc,CAAC,WAAW,GAAG,CAAC,cAAc,CAAC,WAAW,IAAI,CAAC,IAAI;QAEjE,MAAM,0HAAA,CAAA,gBAAa,CAChB,IAAI,CAAC,iBACL,MAAM,CAAC;YACN,cAAc;YACd,iBAAiB,IAAI,OAAO,WAAW;YACvC,iBAAiB;YACjB,cAAc;QAChB,GACC,EAAE,CAAC,MAAM;QAEZ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT;YACA,SAAS;QACX,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA0B,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACF"}},
    {"offset": {"line": 468, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}